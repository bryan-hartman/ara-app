#add delta v
geom_text(aes(x = max_cost_black - (max_cost_black - min_cost_black)/2+1, y = min_value_black - (min_value_black-max_value_grey)/2),
label = TeX("$\\Delta$ V"),
color = "red")+
#add delta c
geom_text(aes(x = max_cost_black + (min_cost_grey - max_cost_black)/2, y = max_value_black - (max_value_black-min_value_black)/2+1),
label = TeX("$\\Delta$ C"),
color = "red")+
#add c*,vbarj
geom_text(aes(x = max_cost_black - 1, y = mean_value_grey),
label = TeX("$(C*,\\bar{V_j})"),
hjust = 'outward',
color = "blue")+
#add cbarj,v*
geom_text(aes(x = mean_cost_grey, y = min_value_black + 1),
label = TeX("$(\\bar{C_j},V*)"),
vjust = 'outward',
color = "blue")+
#add Asubi
geom_text(aes(x = min_cost_black, y = max_value_black),
label = TeX("$A_i$"),
color = "black")+
#add Asubj
geom_text(aes(x = max_cost_grey, y = min_value_grey),
label = TeX("$A_j$"),
color = "black")+
#add C*
geom_text(aes(x = max_cost_black + 1, y = max_value_black),
label = "C*",
color = "black")+
#add Csubj1
geom_text(aes(x = min_cost_grey + 2, y = max_value_black),
label = TeX("$C_{j,(1)}$"),
color = "black")+
#add V*
geom_text(aes(x = min_cost_black - 1, y = min_value_black - 1),
label = "V*",
color = "black")+
#add Vsubjk
geom_text(aes(x = min_cost_black - 1, y = max_value_grey - 1),
label = TeX("$V_{j,(K)}$"),
color = "black")+
labs(x = "Cost", y = "Value", fill= "Alternative")+
guides(color = FALSE, alpha = FALSE, fill = FALSE)+
coord_fixed(xlim = c(50,88), ylim = c(50,85))+
theme(panel.border = element_rect(colour = "black", fill = NA, size = 1.15))+
scale_fill_manual(values = c("black", "grey"))+
scale_color_manual(values = c("black", "grey"))
level1 = function(a, b, maxlength = 1000){
#X and y are seperate alternatives in tibble/dataframe format with cost and value columns
#nSample has a default of 1000, but can be adjusted as desired
#function scales well to 1,000,000 samples and still runs (slowly) at 10,000,000
if(nrow(a)> maxlength){
# #sample alternative
a = a %>% sample_n(maxlength, replace = TRUE)
}
if(nrow(b)> maxlength){
# #sample alternative
b = b %>% sample_n(maxlength, replace = TRUE)
}
#create pairings
#pairings = merge(a,b, by = NULL)
pairings = full_join(a,b, by = character())
colnames(pairings) = c("alt.a","a.value","a.cost","alt.b","b.value","b.cost")
#compute a dominance
pairings = mutate(pairings, a.dominate = if_else(a.value > b.value & a.cost <= b.cost, 1, 0))
#compute b dominance
pairings = mutate(pairings, b.dominate = if_else(a.value < b.value & a.cost >= b.cost, 1, 0))
#compute pareto optimal +
pairings = mutate(pairings, pareto_optimal_plus = if_else(a.value >= b.value & a.cost >= b.cost, 1, 0))
#compute pareto optimal -
pairings = mutate(pairings, pareto_optimal_minus = if_else(a.value <= b.value & a.cost <= b.cost, 1, 0))
#compute a greater than b value
pairings = mutate(pairings, a.GreaterThan.b = if_else(a.value > b.value, 1, 0))
#start building final table
final_count = pairings %>% select(a.dominate, b.dominate, pareto_optimal_plus, pareto_optimal_minus)
#sum observations
final_count = final_count %>% colSums()
final_table = as.data.frame(final_count)
final_table = final_table %>% mutate(percent = final_count/sum(final_count))
#change col names to match the alternatives being examined
row.names(final_table) = c(paste0(str_to_title(a$alternative[1])," dominates ", str_to_title(b$alternative[1])),
paste0(str_to_title(b$alternative[1])," dominates ", str_to_title(a$alternative[1])),
paste0(str_to_title(a$alternative[1]), " is pareto optimal (+)"),
paste0(str_to_title(a$alternative[1]), " is pareto optimal (-)"))
return(final_table)
}
level1(red, green)
ads_score = function(a, b, maxlength = 1000){
temp = level1(a,b, maxlength)
score = (temp$final_count[1]-temp$final_count[2])/sum(temp$final_count)
score = set_names(score,paste0(a$alternative[1], " compared to ", b$alternative[1]))
return(as.data.frame(score))
}
ads_matrix = function(list_of_alt, maxlength = 1000){
#build square matrix of zeros the size of the deminsions of your list
ads_mat = matrix(0, nrow = length(list_of_alt), ncol = length(list_of_alt))
#create dummy row/col headers so that we can dynamically fill it later
dimnames(ads_mat) <- list(rownames(ads_mat, do.NULL = FALSE, prefix = "row"),
colnames(ads_mat, do.NULL = FALSE, prefix = "col"))
#fill matrix by iterating through list, computing ads_score of each alternative against all others
for (i in 1:length(list_of_alt)) {
row.names(ads_mat)[i] = c(list_of_alt[[i]]$alternative[1])
for (j in 1:length(list_of_alt)) {
ads_mat[i,j] = as.numeric(ads_score(list_of_alt[[i]],list_of_alt[[j]],maxlength))
colnames(ads_mat)[j] = c(list_of_alt[[j]]$alternative[1])
}
}
#create new row and add rowsums to it
ads_matrix_final = as_data_frame(ads_mat) %>% mutate(ads_score = rowSums(.)/(length(list_of_alt)-1))
#add back in row names that dropped when converting to dataframe
rownames(ads_matrix_final) = rownames(ads_mat)
return(ads_matrix_final)
}
#build a list of alternatives you wish to conduct calcuations on
list1 = list(red,green,blue, brown, purple, orange)
test = ads_matrix(list1)
ads_matrix = function(list_of_alt, maxlength = 1000){
#build square matrix of zeros the size of the deminsions of your list
ads_mat = matrix(0, nrow = length(list_of_alt), ncol = length(list_of_alt))
print("test")
#create dummy row/col headers so that we can dynamically fill it later
dimnames(ads_mat) <- list(rownames(ads_mat, do.NULL = FALSE, prefix = "row"),
colnames(ads_mat, do.NULL = FALSE, prefix = "col"))
#fill matrix by iterating through list, computing ads_score of each alternative against all others
for (i in 1:length(list_of_alt)) {
row.names(ads_mat)[i] = c(list_of_alt[[i]]$alternative[1])
for (j in 1:length(list_of_alt)) {
ads_mat[i,j] = as.numeric(ads_score(list_of_alt[[i]],list_of_alt[[j]],maxlength))
colnames(ads_mat)[j] = c(list_of_alt[[j]]$alternative[1])
}
}
#create new row and add rowsums to it
ads_matrix_final = as_data_frame(ads_mat) %>% mutate(ads_score = rowSums(.)/(length(list_of_alt)-1))
#add back in row names that dropped when converting to dataframe
rownames(ads_matrix_final) = rownames(ads_mat)
return(ads_matrix_final)
}
#build a list of alternatives you wish to conduct calcuations on
list1 = list(red,green,blue, brown, purple, orange)
test = ads_matrix(list1)
ads_matrix = function(list_of_alt, maxlength = 1000){
#build square matrix of zeros the size of the deminsions of your list
ads_mat = matrix(0, nrow = length(list_of_alt), ncol = length(list_of_alt))
#create dummy row/col headers so that we can dynamically fill it later
dimnames(ads_mat) <- list(rownames(ads_mat, do.NULL = FALSE, prefix = "row"),
colnames(ads_mat, do.NULL = FALSE, prefix = "col"))
print("test")
#fill matrix by iterating through list, computing ads_score of each alternative against all others
for (i in 1:length(list_of_alt)) {
row.names(ads_mat)[i] = c(list_of_alt[[i]]$alternative[1])
for (j in 1:length(list_of_alt)) {
ads_mat[i,j] = as.numeric(ads_score(list_of_alt[[i]],list_of_alt[[j]],maxlength))
colnames(ads_mat)[j] = c(list_of_alt[[j]]$alternative[1])
}
}
#create new row and add rowsums to it
ads_matrix_final = as_data_frame(ads_mat) %>% mutate(ads_score = rowSums(.)/(length(list_of_alt)-1))
#add back in row names that dropped when converting to dataframe
rownames(ads_matrix_final) = rownames(ads_mat)
return(ads_matrix_final)
}
#build a list of alternatives you wish to conduct calcuations on
list1 = list(red,green,blue, brown, purple, orange)
test = ads_matrix(list1)
ads_matrix = function(list_of_alt, maxlength = 1000){
#build square matrix of zeros the size of the deminsions of your list
ads_mat = matrix(0, nrow = length(list_of_alt), ncol = length(list_of_alt))
#create dummy row/col headers so that we can dynamically fill it later
dimnames(ads_mat) <- list(rownames(ads_mat, do.NULL = FALSE, prefix = "row"),
colnames(ads_mat, do.NULL = FALSE, prefix = "col"))
#fill matrix by iterating through list, computing ads_score of each alternative against all others
for (i in 1:length(list_of_alt)) {
row.names(ads_mat)[i] = c(list_of_alt[[i]]$alternative[1])
print("test")
for (j in 1:length(list_of_alt)) {
ads_mat[i,j] = as.numeric(ads_score(list_of_alt[[i]],list_of_alt[[j]],maxlength))
colnames(ads_mat)[j] = c(list_of_alt[[j]]$alternative[1])
}
}
#create new row and add rowsums to it
ads_matrix_final = as_data_frame(ads_mat) %>% mutate(ads_score = rowSums(.)/(length(list_of_alt)-1))
#add back in row names that dropped when converting to dataframe
rownames(ads_matrix_final) = rownames(ads_mat)
return(ads_matrix_final)
}
#build a list of alternatives you wish to conduct calcuations on
list1 = list(red,green,blue, brown, purple, orange)
test = ads_matrix(list1)
ads_matrix = function(list_of_alt, maxlength = 1000){
#build square matrix of zeros the size of the deminsions of your list
ads_mat = matrix(0, nrow = length(list_of_alt), ncol = length(list_of_alt))
#create dummy row/col headers so that we can dynamically fill it later
dimnames(ads_mat) <- list(rownames(ads_mat, do.NULL = FALSE, prefix = "row"),
colnames(ads_mat, do.NULL = FALSE, prefix = "col"))
#fill matrix by iterating through list, computing ads_score of each alternative against all others
for (i in 1:length(list_of_alt)) {
row.names(ads_mat)[i] = c(list_of_alt[[i]]$alternative[1])
for (j in 1:length(list_of_alt)) {
ads_mat[i,j] = as.numeric(ads_score(list_of_alt[[i]],list_of_alt[[j]],maxlength))
print("test")
colnames(ads_mat)[j] = c(list_of_alt[[j]]$alternative[1])
}
}
#create new row and add rowsums to it
ads_matrix_final = as_data_frame(ads_mat) %>% mutate(ads_score = rowSums(.)/(length(list_of_alt)-1))
#add back in row names that dropped when converting to dataframe
rownames(ads_matrix_final) = rownames(ads_mat)
return(ads_matrix_final)
}
#build a list of alternatives you wish to conduct calcuations on
list1 = list(red,green,blue, brown, purple, orange)
test = ads_matrix(list1)
ads_score = function(a, b, maxlength = 1000){
print("test")
temp = level1(a,b, maxlength)
score = (temp$final_count[1]-temp$final_count[2])/sum(temp$final_count)
score = set_names(score,paste0(a$alternative[1], " compared to ", b$alternative[1]))
return(as.data.frame(score))
}
test = ads_matrix(list1)
ads_score = function(a, b, maxlength = 1000){
temp = level1(a,b, maxlength)
print("test")
score = (temp$final_count[1]-temp$final_count[2])/sum(temp$final_count)
score = set_names(score,paste0(a$alternative[1], " compared to ", b$alternative[1]))
return(as.data.frame(score))
}
test = ads_matrix(list1)
level1 = function(a, b, maxlength = 1000){
#X and y are seperate alternatives in tibble/dataframe format with cost and value columns
#nSample has a default of 1000, but can be adjusted as desired
#function scales well to 1,000,000 samples and still runs (slowly) at 10,000,000
if(nrow(a)> maxlength){
# #sample alternative
a = a %>% sample_n(maxlength, replace = TRUE)
}
if(nrow(b)> maxlength){
# #sample alternative
b = b %>% sample_n(maxlength, replace = TRUE)
}
#create pairings
#pairings = merge(a,b, by = NULL)
pairings = full_join(a,b, by = character())
colnames(pairings) = c("alt.a","a.value","a.cost","alt.b","b.value","b.cost")
#compute a dominance
pairings = mutate(pairings, a.dominate = if_else(a.value > b.value & a.cost <= b.cost, 1, 0))
#compute b dominance
pairings = mutate(pairings, b.dominate = if_else(a.value < b.value & a.cost >= b.cost, 1, 0))
#compute pareto optimal +
pairings = mutate(pairings, pareto_optimal_plus = if_else(a.value >= b.value & a.cost >= b.cost, 1, 0))
#compute pareto optimal -
pairings = mutate(pairings, pareto_optimal_minus = if_else(a.value <= b.value & a.cost <= b.cost, 1, 0))
#compute a greater than b value
pairings = mutate(pairings, a.GreaterThan.b = if_else(a.value > b.value, 1, 0))
#start building final table
final_count = pairings %>% select(a.dominate, b.dominate, pareto_optimal_plus, pareto_optimal_minus)
#sum observations
final_count = final_count %>% colSums()
final_table = as.data.frame(final_count)
final_table = final_table %>% mutate(percent = final_count/sum(final_count))
#change col names to match the alternatives being examined
print("test")
row.names(final_table) = c(paste0(str_to_title(a$alternative[1])," dominates ", str_to_title(b$alternative[1])),
paste0(str_to_title(b$alternative[1])," dominates ", str_to_title(a$alternative[1])),
paste0(str_to_title(a$alternative[1]), " is pareto optimal (+)"),
paste0(str_to_title(a$alternative[1]), " is pareto optimal (-)"))
return(final_table)
}
test = ads_matrix(list1)
level1 = function(a, b, maxlength = 1000){
#X and y are seperate alternatives in tibble/dataframe format with cost and value columns
#nSample has a default of 1000, but can be adjusted as desired
#function scales well to 1,000,000 samples and still runs (slowly) at 10,000,000
if(nrow(a)> maxlength){
# #sample alternative
a = a %>% sample_n(maxlength, replace = TRUE)
}
if(nrow(b)> maxlength){
# #sample alternative
b = b %>% sample_n(maxlength, replace = TRUE)
}
#create pairings
#pairings = merge(a,b, by = NULL)
pairings = full_join(a,b, by = character())
colnames(pairings) = c("alt.a","a.value","a.cost","alt.b","b.value","b.cost")
#compute a dominance
pairings = mutate(pairings, a.dominate = if_else(a.value > b.value & a.cost <= b.cost, 1, 0))
#compute b dominance
pairings = mutate(pairings, b.dominate = if_else(a.value < b.value & a.cost >= b.cost, 1, 0))
#compute pareto optimal +
pairings = mutate(pairings, pareto_optimal_plus = if_else(a.value >= b.value & a.cost >= b.cost, 1, 0))
#compute pareto optimal -
pairings = mutate(pairings, pareto_optimal_minus = if_else(a.value <= b.value & a.cost <= b.cost, 1, 0))
#compute a greater than b value
pairings = mutate(pairings, a.GreaterThan.b = if_else(a.value > b.value, 1, 0))
#start building final table
final_count = pairings %>% select(a.dominate, b.dominate, pareto_optimal_plus, pareto_optimal_minus)
#sum observations
final_count = final_count %>% colSums()
final_table = as.data.frame(final_count)
final_table = final_table %>% mutate(percent = final_count/sum(final_count))
#change col names to match the alternatives being examined
# row.names(final_table) = c(paste0(str_to_title(a$alternative[1])," dominates ", str_to_title(b$alternative[1])),
#                            paste0(str_to_title(b$alternative[1])," dominates ", str_to_title(a$alternative[1])),
#                            paste0(str_to_title(a$alternative[1]), " is pareto optimal (+)"),
#                            paste0(str_to_title(a$alternative[1]), " is pareto optimal (-)"))
return(final_table)
}
test = ads_matrix(list1)
test$alt = names(test[1:nrow(test)])
test = test[order(-test$ads_score), , drop = FALSE] %>% select(alt, everything())
test
ads_score = function(a, b, maxlength = 1000){
temp = level1(a,b, maxlength)
score = (temp$final_count[1]-temp$final_count[2])/sum(temp$final_count)
score = set_names(score,paste0(a$alternative[1], " compared to ", b$alternative[1]))
return(as.data.frame(score))
}
level1 = function(a, b, maxlength = 1000){
#X and y are seperate alternatives in tibble/dataframe format with cost and value columns
#nSample has a default of 1000, but can be adjusted as desired
#function scales well to 1,000,000 samples and still runs (slowly) at 10,000,000
if(nrow(a)> maxlength){
# #sample alternative
a = a %>% sample_n(maxlength, replace = TRUE)
}
if(nrow(b)> maxlength){
# #sample alternative
b = b %>% sample_n(maxlength, replace = TRUE)
}
#create pairings
#pairings = merge(a,b, by = NULL)
pairings = full_join(a,b, by = character())
colnames(pairings) = c("alt.a","a.value","a.cost","alt.b","b.value","b.cost")
#compute a dominance
pairings = mutate(pairings, a.dominate = if_else(a.value > b.value & a.cost <= b.cost, 1, 0))
#compute b dominance
pairings = mutate(pairings, b.dominate = if_else(a.value < b.value & a.cost >= b.cost, 1, 0))
#compute pareto optimal +
pairings = mutate(pairings, pareto_optimal_plus = if_else(a.value >= b.value & a.cost >= b.cost, 1, 0))
#compute pareto optimal -
pairings = mutate(pairings, pareto_optimal_minus = if_else(a.value <= b.value & a.cost <= b.cost, 1, 0))
#compute a greater than b value
pairings = mutate(pairings, a.GreaterThan.b = if_else(a.value > b.value, 1, 0))
#start building final table
final_count = pairings %>% select(a.dominate, b.dominate, pareto_optimal_plus, pareto_optimal_minus)
#sum observations
final_count = final_count %>% colSums()
final_table = as.data.frame(final_count)
final_table = final_table %>% mutate(percent = final_count/sum(final_count))
#change col names to match the alternatives being examined
row.names(final_table) = c(paste0(str_to_title(a$alternative[1])," dominates ", str_to_title(b$alternative[1])),
paste0(str_to_title(b$alternative[1])," dominates ", str_to_title(a$alternative[1])),
paste0(str_to_title(a$alternative[1]), " is pareto optimal (+)"),
paste0(str_to_title(a$alternative[1]), " is pareto optimal (-)"))
return(final_table)
}
test = ads_matrix(list1)
test = ads_matrix(list1)
ads_matrix = function(list_of_alt, maxlength = 1000){
#build square matrix of zeros the size of the deminsions of your list
ads_mat = matrix(0, nrow = length(list_of_alt), ncol = length(list_of_alt))
#create dummy row/col headers so that we can dynamically fill it later
dimnames(ads_mat) <- list(rownames(ads_mat, do.NULL = FALSE, prefix = "row"),
colnames(ads_mat, do.NULL = FALSE, prefix = "col"))
#fill matrix by iterating through list, computing ads_score of each alternative against all others
for (i in 1:length(list_of_alt)) {
row.names(ads_mat)[i] = c(list_of_alt[[i]]$alternative[1])
for (j in 1:length(list_of_alt)) {
if(i = j){
ads_mat[i,j] = 0
} else {
ads_mat[i,j] = as.numeric(ads_score(list_of_alt[[i]],list_of_alt[[j]],maxlength))
colnames(ads_mat)[j] = c(list_of_alt[[j]]$alternative[1])
}
}
}
#create new row and add rowsums to it
ads_matrix_final = as_data_frame(ads_mat) %>% mutate(ads_score = rowSums(.)/(length(list_of_alt)-1))
#add back in row names that dropped when converting to dataframe
rownames(ads_matrix_final) = rownames(ads_mat)
return(ads_matrix_final)
}
ads_matrix = function(list_of_alt, maxlength = 1000){
#build square matrix of zeros the size of the deminsions of your list
ads_mat = matrix(0, nrow = length(list_of_alt), ncol = length(list_of_alt))
#create dummy row/col headers so that we can dynamically fill it later
dimnames(ads_mat) <- list(rownames(ads_mat, do.NULL = FALSE, prefix = "row"),
colnames(ads_mat, do.NULL = FALSE, prefix = "col"))
#fill matrix by iterating through list, computing ads_score of each alternative against all others
for (i in 1:length(list_of_alt)) {
row.names(ads_mat)[i] = c(list_of_alt[[i]]$alternative[1])
for (j in 1:length(list_of_alt)) {
if(i == j){
ads_mat[i,j] = 0
} else {
ads_mat[i,j] = as.numeric(ads_score(list_of_alt[[i]],list_of_alt[[j]],maxlength))
colnames(ads_mat)[j] = c(list_of_alt[[j]]$alternative[1])
}
}
}
#create new row and add rowsums to it
ads_matrix_final = as_data_frame(ads_mat) %>% mutate(ads_score = rowSums(.)/(length(list_of_alt)-1))
#add back in row names that dropped when converting to dataframe
rownames(ads_matrix_final) = rownames(ads_mat)
return(ads_matrix_final)
}
test = ads_matrix(list1)
test$alt = names(test[1:nrow(test)])
test = test[order(-test$ads_score), , drop = FALSE] %>% select(alt, everything())
test
ads_score = function(a, b, maxlength = 1000){
temp = level1(a,b, maxlength)
score = (temp$final_count[1]-temp$final_count[2])/sum(temp$final_count)
score = set_names(score,paste0(a$Alternative[1], " compared to ", b$Alternative[1]))
return(as.data.frame(score))
}
ads_matrix = function(list_of_alt, maxlength = 1000){
#build square matrix of zeros the size of the deminsions of your list
ads_mat = matrix(0, nrow = length(list_of_alt), ncol = length(list_of_alt))
#create dummy row/col headers so that we can dynamically fill it later
dimnames(ads_mat) <- list(rownames(ads_mat, do.NULL = FALSE, prefix = "row"),
colnames(ads_mat, do.NULL = FALSE, prefix = "col"))
#fill matrix by iterating through list, computing ads_score of each Alternative against all others
for (i in 1:length(list_of_alt)) {
row.names(ads_mat)[i] = c(list_of_alt[[i]]$Alternative[1])
for (j in 1:length(list_of_alt)) {
if(i == j){
ads_mat[i,j] = 0
} else {
ads_mat[i,j] = as.numeric(ads_score(list_of_alt[[i]],list_of_alt[[j]],maxlength))
colnames(ads_mat)[j] = c(list_of_alt[[j]]$Alternative[1])
}
}
}
#create new row and add rowsums to it
ads_matrix_final = as_data_frame(ads_mat) %>% mutate(ads_score = rowSums(.)/(length(list_of_alt)-1))
#add back in row names that dropped when converting to dataframe
rownames(ads_matrix_final) = rownames(ads_mat)
return(ads_matrix_final)
}
runApp('C:/Users/bryan.hartman/OneDrive - West Point/Desktop/Research/Design')
runApp('C:/Users/bryan.hartman/OneDrive - West Point/Desktop/Research/Design')
runApp('C:/Users/bryan.hartman/OneDrive - West Point/Desktop/Research/Design')
runApp('C:/Users/bryan.hartman/OneDrive - West Point/Desktop/Research/Design')
runApp('C:/Users/bryan.hartman/OneDrive - West Point/Desktop/Research/Design')
runApp('C:/Users/bryan.hartman/OneDrive - West Point/Desktop/Research/Design')
runApp('C:/Users/bryan.hartman/OneDrive - West Point/Desktop/Research/Design')
runApp('C:/Users/bryan.hartman/OneDrive - West Point/Desktop/Research/Design')
runApp('C:/Users/bryan.hartman/OneDrive - West Point/Desktop/Research/Design')
runApp('C:/Users/bryan.hartman/OneDrive - West Point/Desktop/Research/Design')
#build a list of alternatives you wish to conduct calcuations on
list1 = list(red,green,blue, brown, purple, orange)
list1
list(all.alternatives$alternative)
list(all.alternatives)
test <- group_by(all.alternatives, alternative)
group_split(test)
runApp('C:/Users/bryan.hartman/OneDrive - West Point/Desktop/Research/Design')
runApp('C:/Users/bryan.hartman/OneDrive - West Point/Desktop/Research/Design')
runApp('C:/Users/bryan.hartman/OneDrive - West Point/Desktop/Research/Design')
runApp('C:/Users/bryan.hartman/OneDrive - West Point/Desktop/Research/Design')
install.packages("dtplyr")
install.packages("dtplyr")
install.packages("dtplyr")
install.packages("dtplyr")
install.packages("dtplyr")
library(dtplyr)
?dtplyr
install.packages("rlang")
install.packages("rlang")
library(dtplyr)
shiny::runApp('C:/Users/bryan.hartman/OneDrive - West Point/Desktop/Research/Design')
runApp('C:/Users/bryan.hartman/OneDrive - West Point/Desktop/Research/Design')
sessionInfo()
install.packages("rlang")
install.packages("rlang")
install.packages("rlang")
install.packages("rlang")
install.packages("rlang")
install.packages("rlang")
install.packages("rlang")
install.packages("rlang")
sessionInfo()
remove.packages("rlang")
.libPaths()
install.packages("https://cran.r-project.org/src/contrib/Archive/rlang/rlang_0.4.9.tar.gz", repo=NULL, type="source")
shiny::runApp('C:/Users/bryan.hartman/OneDrive - West Point/Desktop/Research/Design')
install.packages("https://cran.r-project.org/src/contrib/Archive/rlang/rlang_0.4.9.tar.gz", repo=NULL, type="source")
packageVersion("rlang")
runApp('C:/Users/bryan.hartman/OneDrive - West Point/Desktop/Research/Design')
library(rlang)
sessionInfo()
n <- 1000
profit_vec <- rep(0, n)
for(i in 1:n){
burgers <- rnorm(1, mean = 30, sd = 10)
wraps <- rnorm(1, mean = 20, sd = 5)
salads <- rnorm(1, mean = 10, sd = 2.5)
profit_vec[i] <- burgers * 1.5 + wraps * .75 + salads * .5
}
quantile(profit_vec, .01)
quantile(profit_vec, .99)
ecdf(profit_vec)(50)
1 - ecdf(profit_vec)(55)
par(mfrow=c(1,2))
hist(profit_vec,breaks = 30)
plot(ecdf(profit_vec))
shiny::runApp('C:/Users/bryan.hartman/OneDrive - West Point/Desktop/Research/Design/ara-app')
runApp('C:/Users/bryan.hartman/OneDrive - West Point/Desktop/Research/Design/ara-app')
runApp('C:/Users/bryan.hartman/OneDrive - West Point/Desktop/Research/Design/ara-app')
